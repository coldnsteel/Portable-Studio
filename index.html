<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ¸ Kozmic Pro Studio - Ultimate Portable Edition ðŸŒŒ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
            animation: cosmicPulse 6s ease-in-out infinite alternate;
            user-select: none;
        }

        @keyframes cosmicPulse {
            0% { background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460); }
            100% { background: linear-gradient(45deg, #16213e, #0f3460, #1a1a2e); }
        }

        .studio-header {
            text-align: center;
            padding: 15px;
            position: relative;
            z-index: 100;
        }

        .studio-title {
            font-size: clamp(1.5rem, 4vw, 3rem);
            background: linear-gradient(45deg, #ff6b9d, #4ecdc4, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 107, 157, 0.5);
            margin-bottom: 8px;
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 0 20px rgba(255, 107, 157, 0.5), 0 0 40px rgba(78, 205, 196, 0.3); }
            100% { text-shadow: 0 0 40px rgba(78, 205, 196, 0.7), 0 0 60px rgba(255, 107, 157, 0.5); }
        }

        .studio-subtitle {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            color: #4ecdc4;
            opacity: 0.9;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            padding: 10px 15px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .cosmic-canvas-container {
            position: relative;
            width: 100%;
            height: 50vh;
            min-height: 300px;
            max-height: 500px;
            background: linear-gradient(45deg, #2c2c4e, #1a1a2e);
            border: 3px solid #ff6b9d;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                0 0 30px rgba(255, 107, 157, 0.4),
                inset 0 0 50px rgba(0, 0, 0, 0.3);
        }

        #kozmicCanvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 17px;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .status-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4ecdc4;
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 0.8rem;
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
        }

        .pitch-display {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd93d;
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 0.8rem;
            color: #ffd93d;
            font-family: 'Courier New', monospace;
            backdrop-filter: blur(10px);
        }

        .power-indicator {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #4ecdc4;
        }

        .power-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ecdc4, #ff6b9d, #ffd93d);
            transition: width 0.1s ease;
            border-radius: 3px;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .control-module {
            background: rgba(44, 44, 78, 0.9);
            border: 2px solid #ff6b9d;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .control-module:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(255, 107, 157, 0.3);
            border-color: #4ecdc4;
        }

        .module-title {
            font-size: 1.1rem;
            color: #ff6b9d;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 107, 157, 0.5);
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .kozmic-btn {
            background: linear-gradient(45deg, #ff6b9d, #4ecdc4);
            border: none;
            padding: 12px 8px;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .kozmic-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.4);
        }

        .kozmic-btn:active {
            transform: translateY(0);
        }

        .kozmic-btn.active {
            background: linear-gradient(45deg, #ffd93d, #ff6b9d);
            box-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
        }

        .effect-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 10px 0;
        }

        .effect-btn {
            padding: 8px 4px;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4ecdc4;
            color: #4ecdc4;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .effect-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: #ff6b9d;
            color: #ff6b9d;
        }

        .effect-btn.active {
            background: #4ecdc4;
            color: #000;
        }

        .frequency-visualizer {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            height: 60px;
            margin: 15px 0;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
        }

        .freq-bar {
            background: linear-gradient(to top, #4ecdc4, #ff6b9d, #ffd93d);
            border-radius: 3px;
            transition: height 0.1s ease;
            min-height: 2px;
            opacity: 0.7;
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }

        .status-item {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 8px;
            border-left: 3px solid #4ecdc4;
            font-size: 0.8rem;
        }

        .status-value {
            color: #ffd93d;
            font-weight: bold;
        }

        .heuristic-console {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ff6b9d;
            max-height: 120px;
            overflow-y: auto;
            font-size: 0.75rem;
            line-height: 1.3;
        }

        .debug-line {
            margin: 2px 0;
            opacity: 0.9;
        }

        .debug-info { color: #4ecdc4; }
        .debug-success { color: #4ade80; }
        .debug-warning { color: #fbbf24; }
        .debug-error { color: #f87171; }

        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(44, 44, 78, 0.95);
            border: 2px solid #ff6b9d;
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(15px);
            z-index: 1000;
        }

        .mobile-btn-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .mobile-btn {
            padding: 10px 5px;
            background: linear-gradient(45deg, #ff6b9d, #4ecdc4);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
        }

        .cosmic-creature {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ff6b9d, #4ecdc4, #ffd93d);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 999;
            animation: creatureFloat 4s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(255, 107, 157, 0.6);
            transition: all 0.3s ease;
        }

        @keyframes creatureFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-8px) rotate(5deg); }
            50% { transform: translateY(-15px) rotate(0deg); }
            75% { transform: translateY(-8px) rotate(-5deg); }
        }

        .creature-pulse {
            animation: creaturePulse 0.6s ease-out;
        }

        @keyframes creaturePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); box-shadow: 0 0 40px rgba(255, 217, 61, 0.8); }
            100% { transform: scale(1); }
        }

        .battery-indicator {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            padding: 5px 10px;
            font-size: 0.8rem;
            color: #4ecdc4;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .battery-level {
            width: 20px;
            height: 10px;
            border: 1px solid #4ecdc4;
            border-radius: 2px;
            position: relative;
        }

        .battery-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #fbbf24, #f87171);
            border-radius: 1px;
            transition: width 0.3s ease;
        }

        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .main-container {
                padding: 5px 10px;
                gap: 15px;
            }

            .cosmic-canvas-container {
                height: 40vh;
                min-height: 250px;
            }

            .control-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .control-module {
                padding: 15px;
            }

            .button-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .mobile-controls {
                display: block;
            }

            .cosmic-creature {
                bottom: 180px;
                right: 15px;
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }

            .battery-indicator {
                top: 10px;
                right: 10px;
                font-size: 0.7rem;
                padding: 3px 8px;
            }
        }

        @media (max-width: 480px) {
            .studio-title {
                font-size: 1.8rem;
            }

            .cosmic-canvas-container {
                height: 35vh;
                min-height: 200px;
            }

            .effect-selector {
                grid-template-columns: 1fr 1fr;
            }

            .frequency-visualizer {
                height: 40px;
            }
        }

        /* REDUCED MOTION */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* LANDSCAPE ORIENTATION */
        @media (orientation: landscape) and (max-height: 600px) {
            .cosmic-canvas-container {
                height: 60vh;
            }
        }
    </style>
</head>
<body>
    <div class="battery-indicator">
        <span id="batteryText">ðŸ”‹ 100%</span>
        <div class="battery-level">
            <div class="battery-fill" id="batteryFill" style="width: 100%"></div>
        </div>
    </div>

    <div class="studio-header">
        <h1 class="studio-title">ðŸŽ¸ KOZMIC PRO STUDIO ðŸŒŒ</h1>
        <p class="studio-subtitle">Ultimate Portable Recording Experience</p>
    </div>

    <div class="main-container">
        <div class="cosmic-canvas-container">
            <canvas id="kozmicCanvas"></canvas>
            <div class="canvas-overlay">
                <div class="status-badge" id="statusBadge">READY</div>
                <div class="pitch-display" id="pitchDisplay">Pitch: Ready</div>
                <div class="power-indicator">
                    <div class="power-bar" id="powerBar"></div>
                </div>
            </div>
        </div>

        <div class="control-grid">
            <!-- INPUT CONTROL MODULE -->
            <div class="control-module">
                <h3 class="module-title">ðŸŽµ AUDIO INPUT</h3>
                <div class="button-grid">
                    <button class="kozmic-btn" id="connectBtn">CONNECT</button>
                    <button class="kozmic-btn" id="tunerBtn">TUNER</button>
                    <button class="kozmic-btn" id="recordBtn">RECORD</button>
                    <button class="kozmic-btn" id="amplifyBtn">AMPLIFY</button>
                </div>
                <div class="frequency-visualizer" id="freqViz">
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                </div>
                <div class="status-grid">
                    <div class="status-item">
                        Input: <span class="status-value" id="inputStatus">READY</span>
                    </div>
                    <div class="status-item">
                        Level: <span class="status-value" id="levelStatus">0%</span>
                    </div>
                </div>
            </div>

            <!-- EFFECTS MODULE -->
            <div class="control-module">
                <h3 class="module-title">ðŸŒ€ COSMIC EFFECTS</h3>
                <div class="effect-selector">
                    <button class="effect-btn active" data-effect="particles">PARTICLES</button>
                    <button class="effect-btn" data-effect="nebula">NEBULA</button>
                    <button class="effect-btn" data-effect="waveform">WAVEFORM</button>
                    <button class="effect-btn" data-effect="cosmic">COSMIC</button>
                    <button class="effect-btn" data-effect="spiral">SPIRAL</button>
                    <button class="effect-btn" data-effect="burst">BURST</button>
                </div>
                <div class="button-grid">
                    <button class="kozmic-btn" id="effectToggle">EFFECTS ON</button>
                    <button class="kozmic-btn" id="intensityBtn">INTENSITY</button>
                </div>
                <div class="status-grid">
                    <div class="status-item">
                        Effect: <span class="status-value" id="currentEffect">PARTICLES</span>
                    </div>
                    <div class="status-item">
                        Power: <span class="status-value" id="effectPower">50%</span>
                    </div>
                </div>
            </div>

            <!-- HEURISTIC ANALYSIS MODULE -->
            <div class="control-module">
                <h3 class="module-title">ðŸ§  HEURISTIC ANALYSIS</h3>
                <div class="button-grid">
                    <button class="kozmic-btn" id="heuristicBtn">ANALYZE</button>
                    <button class="kozmic-btn" id="booleanBtn">BOOLEAN</button>
                    <button class="kozmic-btn" id="crisisBtn">CRISIS</button>
                    <button class="kozmic-btn" id="debugBtn">DEBUG</button>
                </div>
                <div class="heuristic-console" id="heuristicConsole">
                    <div class="debug-line debug-info">ðŸŒŒ Kozmic Studio initialized...</div>
                    <div class="debug-line debug-success">âœ… All systems nominal</div>
                    <div class="debug-line debug-info">ðŸŽ¸ Ready for cosmic shredding!</div>
                </div>
                <div class="status-grid">
                    <div class="status-item">
                        Audio: <span class="status-value" id="audioBoolean">FALSE</span>
                    </div>
                    <div class="status-item">
                        WebGL: <span class="status-value" id="webglBoolean">FALSE</span>
                    </div>
                </div>
            </div>

            <!-- SESSION CONTROL MODULE -->
            <div class="control-module">
                <h3 class="module-title">ðŸ’¾ SESSION CONTROL</h3>
                <div class="button-grid">
                    <button class="kozmic-btn" id="saveBtn">SAVE</button>
                    <button class="kozmic-btn" id="loadBtn">LOAD</button>
                    <button class="kozmic-btn" id="exportBtn">EXPORT</button>
                    <button class="kozmic-btn" id="resetBtn">RESET</button>
                </div>
                <div class="status-grid">
                    <div class="status-item">
                        Session: <span class="status-value" id="sessionTime">0:00</span>
                    </div>
                    <div class="status-item">
                        Battery: <span class="status-value" id="batteryStatus">100%</span>
                    </div>
                    <div class="status-item">
                        Freq: <span class="status-value" id="dominantFreq">440Hz</span>
                    </div>
                    <div class="status-item">
                        Mode: <span class="status-value" id="modeStatus">PORTABLE</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MOBILE CONTROLS -->
    <div class="mobile-controls" id="mobileControls">
        <div class="mobile-btn-row">
            <button class="mobile-btn" onclick="connectAudio()">CONNECT</button>
            <button class="mobile-btn" onclick="toggleRecord()">REC</button>
            <button class="mobile-btn" onclick="cycleEffect()">FX</button>
            <button class="mobile-btn" onclick="toggleAmplify()">AMP</button>
        </div>
    </div>

    <!-- COSMIC CREATURE -->
    <div class="cosmic-creature" id="cosmicCreature" onclick="pulseCreature()">ðŸŒŒ</div>

    <script>
        // ULTIMATE PORTABLE KOZMIC STUDIO CORE
        let scene, camera, renderer, particles = [];
        let audioContext, analyser, dataArray, mediaRecorder;
        let audioStream = null, isRecording = false, tunerActive = false;
        let currentEffect = 'particles', effectsActive = true, isAmplified = false;
        let particleIntensity = 50, sessionStart = Date.now();
        let batteryLevel = 100, powerSaving = false, creatureClicks = 0;
        let recordedChunks = [], heuristicData = {};

        // PITCH DETECTION CLASS
        class KozmicPitchDetector {
            constructor(sampleRate = 44100) {
                this.sampleRate = sampleRate;
                this.threshold = 0.1;
                this.noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            }

            detectPitch(buffer) {
                const correlations = this.autoCorrelate(buffer);
                let maxVal = 0, bestOffset = -1;

                for (let i = 1; i < correlations.length; i++) {
                    if (correlations[i] > this.threshold && correlations[i] > maxVal) {
                        maxVal = correlations[i];
                        bestOffset = i;
                    }
                }

                if (bestOffset === -1) return null;
                
                const frequency = this.sampleRate / bestOffset;
                return this.frequencyToNote(frequency);
            }

            autoCorrelate(buffer) {
                const correlations = new Array(buffer.length);
                for (let lag = 0; lag < buffer.length; lag++) {
                    let sum = 0;
                    for (let index = 0; index < buffer.length - lag; index++) {
                        sum += buffer[index] * buffer[index + lag];
                    }
                    correlations[lag] = sum / (buffer.length - lag);
                }
                return correlations;
            }

            frequencyToNote(frequency) {
                if (frequency < 80 || frequency > 2000) return null;
                
                const A4 = 440;
                const noteNumber = Math.round(12 * Math.log2(frequency / A4)) + 69;
                const octave = Math.floor(noteNumber / 12) - 1;
                const noteIndex = noteNumber % 12;
                const cents = Math.round(1200 * Math.log2(frequency / (A4 * Math.pow(2, (noteNumber - 69) / 12))));
                
                return {
                    note: this.noteNames[noteIndex] + octave,
                    frequency: frequency.toFixed(1),
                    cents: cents
                };
            }
        }

        const pitchDetector = new KozmicPitchDetector();

        // UTILITY FUNCTIONS
        function safeElement(id) {
            const el = document.getElementById(id);
            return el || { textContent: '', style: {}, classList: { add: () => {}, remove: () => {}, toggle: () => {} } };
        }

        function debugLog(message, type = 'info') {
            const console = safeElement('heuristicConsole');
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                info: 'debug-info',
                success: 'debug-success',
                warning: 'debug-warning',
                error: 'debug-error'
            };
            
            const logLine = document.createElement('div');
            logLine.className = `debug-line ${colors[type]}`;
            logLine.textContent = `[${timestamp}] ${message}`;
            
            console.appendChild(logLine);
            console.scrollTop = console.scrollHeight;
            
            // Keep only last 20 lines
            while (console.children.length > 20) {
                console.removeChild(console.firstChild);
            }
        }

        // WEBGL INITIALIZATION
        function initWebGL() {
            try {
                const canvas = document.getElementById('kozmicCanvas');
                const container = canvas.parentElement;
                
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    alpha: true,
                    antialias: !powerSaving,
                    powerPreference: powerSaving ? "low-power" : "high-performance"
                });
                
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(powerSaving ? 1 : Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x000011, 0.1);
                
                camera.position.z = 5;
                
                createParticleSystem();
                startRenderLoop();
                
                safeElement('webglBoolean').textContent = 'TRUE';
                debugLog('WebGL initialized successfully! ðŸŒŒ', 'success');
                
                return true;
            } catch (error) {
                debugLog(`WebGL failed: ${error.message}`, 'error');
                return false;
            }
        }

        function createParticleSystem() {
            // Clear existing particles
            particles.forEach(particle => scene.remove(particle));
            particles = [];

            const count = powerSaving ? 100 : Math.min(200, particleIntensity * 4);
            
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(0.02, powerSaving ? 6 : 8, powerSaving ? 6 : 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
                    transparent: true,
                    opacity: 0.8
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                
                particle.userData = {
                    originalPos: particle.position.clone(),
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 1.5
                };
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function startRenderLoop() {
            function animate() {
                if (renderer) {
                    requestAnimationFrame(animate);
                    updateParticleEffects();
                    renderer.render(scene, camera);
                }
            }
            animate();
        }

        function updateParticleEffects() {
            if (!particles.length) return;

            const time = Date.now() * 0.001;
            const audioLevel = getAudioLevel();
            const multiplier = isAmplified ? 2 : 1;
            const creature = safeElement('cosmicCreature');

            particles.forEach((particle, i) => {
                const userData = particle.userData;
                const phase = userData.phase + time * userData.speed;

                switch (currentEffect) {
                    case 'particles':
                        particle.position.x = userData.originalPos.x + Math.sin(phase) * audioLevel * 2 * multiplier;
                        particle.position.y = userData.originalPos.y + Math.cos(phase * 1.3) * audioLevel * 2 * multiplier;
                        particle.position.z = userData.originalPos.z + Math.sin(phase * 0.7) * audioLevel * multiplier;
                        break;

                    case 'nebula':
                        const radius = 3 + audioLevel * 2 * multiplier;
                        particle.position.x = Math.cos(phase + i * 0.1) * radius;
                        particle.position.y = Math.sin(phase + i * 0.1) * radius;
                        particle.position.z = Math.sin(time * 0.5 + i * 0.05) * audioLevel * 3;
                        break;

                    case 'waveform':
                        particle.position.x = (i / particles.length) * 10 - 5;
                        particle.position.y = Math.sin(time * 2 + i * 0.2) * audioLevel * 3 * multiplier;
                        particle.position.z = Math.cos(time + i * 0.1) * audioLevel * 2;
                        break;

                    case 'cosmic':
                        const distance = particle.position.length();
                        if (distance > 0.1) {
                            particle.position.multiplyScalar(1 - (0.02 + audioLevel * 0.03));
                            particle.position.applyAxisAngle(new THREE.Vector3(0, 0, 1), 0.1);
                        } else {
                            particle.position.copy(userData.originalPos);
                        }
                        break;

                    case 'spiral':
                        const spiralRadius = 2 + audioLevel * 3 * multiplier;
                        const spiralSpeed = 0.02 + audioLevel * 0.05;
                        particle.position.x = Math.cos(time * spiralSpeed + i * 0.3) * spiralRadius;
                        particle.position.y = Math.sin(time * spiralSpeed + i * 0.3) * spiralRadius;
                        particle.position.z = (i / particles.length) * 6 - 3 + Math.sin(time + i * 0.1) * audioLevel * 2;
                        break;

                    case 'burst':
                        if (audioLevel > 0.6) {
                            const burstForce = (audioLevel - 0.6) * 0.5;
                            const direction = particle.position.clone().normalize();
                            particle.position.addScaledVector(direction, burstForce);
                        }
                        if (particle.position.length() > 8) {
                            particle.position.copy(userData.originalPos);
                        }
                        break;
                }

                // Color based on audio with enhanced responsiveness
                const hue = (time * 0.1 + i * 0.01 + audioLevel * 0.5) % 1;
                particle.material.color.setHSL(hue, 1, 0.5 + audioLevel * 0.3);
                particle.material.opacity = 0.5 + audioLevel * 0.5;
            });

            // Enhanced creature audio reactivity
            const scale = 1 + audioLevel * 0.5;
            const translateY = audioLevel * 20;
            const opacity = 0.7 + audioLevel * 0.3;
            
            creature.style.transform = `scale(${scale}) translateY(-${translateY}px)`;
            creature.style.opacity = opacity;
            
            if (audioLevel > 0.8) {
                creature.style.filter = `brightness(${1 + audioLevel}) drop-shadow(0 0 20px #ff6b9d)`;
            } else {
                creature.style.filter = 'brightness(1)';
            }
        }

        // AUDIO SYSTEM
        async function connectAudio() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    } 
                });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 44100
                });
                
                const source = audioContext.createMediaStreamSource(audioStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = powerSaving ? 512 : 2048;
                analyser.smoothingTimeConstant = 0.8;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                source.connect(analyser);
                
                startVisualization();
                
                safeElement('connectBtn').textContent = 'CONNECTED';
                safeElement('connectBtn').classList.add('active');
                safeElement('inputStatus').textContent = 'LIVE';
                safeElement('audioBoolean').textContent = 'TRUE';
                
                debugLog('Audio connected successfully! ðŸŽµ', 'success');
                
            } catch (error) {
                debugLog(`Audio connection failed: ${error.message}`, 'error');
                alert('Please allow microphone access for the full Kozmic experience!');
            }
        }

        function getAudioLevel() {
            if (!analyser || !dataArray) return 0;
            
            analyser.getByteFrequencyData(dataArray);
            const sum = dataArray.reduce((a, b) => a + b, 0);
            return Math.min((sum / dataArray.length) / 128, 1);
        }

        function startVisualization() {
            function updateVisuals() {
                if (!analyser || !dataArray) return;

                try {
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Update power bar
                    const audioLevel = getAudioLevel();
                    safeElement('powerBar').style.width = (audioLevel * 100) + '%';
                    safeElement('levelStatus').textContent = Math.round(audioLevel * 100) + '%';

                    // Update frequency bars
                    const freqBars = document.querySelectorAll('.freq-bar');
                    freqBars.forEach((bar, index) => {
                        const dataIndex = Math.floor((index / freqBars.length) * dataArray.length);
                        const amplitude = dataArray[dataIndex] / 255;
                        bar.style.height = (amplitude * 50) + 'px';
                        bar.style.opacity = 0.4 + amplitude * 0.6;
                    });

                    // Pitch detection for tuner
                    if (tunerActive) {
                        analyser.getByteTimeDomainData(dataArray);
                        const pitch = pitchDetector.detectPitch(Array.from(dataArray).map(x => (x - 128) / 128));
                        
                        if (pitch) {
                            const accuracy = Math.abs(pitch.cents) < 5 ? 'PERFECT' : 
                                           Math.abs(pitch.cents) < 15 ? 'GOOD' : 'ADJUST';
                            safeElement('pitchDisplay').textContent = `${pitch.note} ${pitch.frequency}Hz (${accuracy})`;
                            safeElement('dominantFreq').textContent = pitch.frequency + 'Hz';
                        }
                    }

                    // SINWE Integration
                    detectMixerEffect();

                    requestAnimationFrame(updateVisuals);
                } catch (error) {
                    debugLog(`Visualization error: ${error.message}`, 'error');
                }
            }
            
            updateVisuals();
            detectBeat();
        }

        // RECORDING SYSTEM
        function toggleRecord() {
            if (!audioStream) {
                debugLog('Connect audio first!', 'warning');
                return;
            }

            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                safeElement('recordBtn').textContent = 'RECORD';
                safeElement('recordBtn').classList.remove('active');
                debugLog('Recording stopped â¹ï¸', 'success');
            } else {
                recordedChunks = [];
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `kozmic-${currentEffect}-${Date.now()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                    debugLog('Recording saved! ðŸ’¾', 'success');
                };

                mediaRecorder.start();
                isRecording = true;
                safeElement('recordBtn').textContent = 'STOP';
                safeElement('recordBtn').classList.add('active');
                debugLog('Recording started ðŸ”´', 'info');
            }
        }

        // TUNER SYSTEM
        function toggleTuner() {
            tunerActive = !tunerActive;
            safeElement('tunerBtn').classList.toggle('active');
            
            if (tunerActive) {
                safeElement('tunerBtn').textContent = 'TUNER ON';
                safeElement('pitchDisplay').textContent = 'Tuning...';
                debugLog('Guitar tuner activated ðŸŽ¸', 'info');
            } else {
                safeElement('tunerBtn').textContent = 'TUNER';
                safeElement('pitchDisplay').textContent = 'Pitch: Ready';
                debugLog('Guitar tuner deactivated', 'info');
            }
        }

        // AMPLIFY MODE
        function toggleAmplify() {
            isAmplified = !isAmplified;
            safeElement('amplifyBtn').classList.toggle('active');
            safeElement('amplifyBtn').textContent = isAmplified ? 'AMPLIFIED' : 'AMPLIFY';
            debugLog(`Amplify mode ${isAmplified ? 'ON' : 'OFF'} ðŸ”Š`, 'info');
        }

        // EFFECT SYSTEM
        function setEffect(effectName) {
            currentEffect = effectName;
            safeElement('currentEffect').textContent = effectName.toUpperCase();
            
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-effect="${effectName}"]`).classList.add('active');
            
            debugLog(`Effect changed to ${effectName.toUpperCase()} ðŸŒ€`, 'info');
        }

        function cycleEffect() {
            const effects = ['particles', 'nebula', 'waveform', 'cosmic', 'spiral', 'burst'];
            const currentIndex = effects.indexOf(currentEffect);
            const nextIndex = (currentIndex + 1) % effects.length;
            setEffect(effects[nextIndex]);
        }

        function toggleEffects() {
            effectsActive = !effectsActive;
            safeElement('effectToggle').classList.toggle('active');
            safeElement('effectToggle').textContent = effectsActive ? 'EFFECTS ON' : 'EFFECTS OFF';
            
            if (!effectsActive) {
                particles.forEach(particle => {
                    particle.position.copy(particle.userData.originalPos);
                });
            }
            
            debugLog(`Effects ${effectsActive ? 'enabled' : 'disabled'} âœ¨`, 'info');
        }

        function adjustIntensity() {
            particleIntensity = particleIntensity >= 100 ? 25 : particleIntensity + 25;
            safeElement('effectPower').textContent = particleIntensity + '%';
            safeElement('intensityBtn').textContent = `${particleIntensity}%`;
            
            // Recreate particles with new intensity
            if (scene) {
                createParticleSystem();
            }
            
            debugLog(`Intensity set to ${particleIntensity}% âš¡`, 'info');
        }

        // HEURISTIC ANALYSIS SYSTEM
        function performHeuristicAnalysis() {
            const sessionDuration = (Date.now() - sessionStart) / 1000;
            const audioConnected = !!audioStream;
            const webglActive = !!renderer;
            
            heuristicData = {
                sessionDuration: sessionDuration,
                audioConnected: audioConnected,
                webglActive: webglActive,
                currentEffect: currentEffect,
                particleCount: particles.length,
                amplified: isAmplified,
                recording: isRecording,
                tunerActive: tunerActive,
                batteryLevel: batteryLevel,
                powerSaving: powerSaving
            };

            debugLog('ðŸ§  HEURISTIC ANALYSIS COMPLETE', 'success');
            debugLog(`Session: ${Math.floor(sessionDuration)}s | Particles: ${particles.length}`, 'info');
            debugLog(`Audio: ${audioConnected} | WebGL: ${webglActive} | Effect: ${currentEffect}`, 'info');
            debugLog(`Battery: ${batteryLevel}% | Power Save: ${powerSaving}`, 'info');
            
            return heuristicData;
        }

        function performBooleanCheck() {
            const checks = {
                audio: !!audioStream,
                webgl: !!renderer,
                recording: isRecording,
                tuner: tunerActive,
                amplified: isAmplified,
                effects: effectsActive,
                kozmicVibe: !!audioStream && !!renderer && effectsActive
            };

            safeElement('audioBoolean').textContent = checks.audio ? 'TRUE âœ…' : 'FALSE âŒ';
            safeElement('webglBoolean').textContent = checks.webgl ? 'TRUE âœ…' : 'FALSE âŒ';

            debugLog('ðŸ” BOOLEAN STATUS CHECK INITIATED', 'success');
            Object.entries(checks).forEach(([key, value]) => {
                debugLog(`${key.toUpperCase()}: ${value ? 'TRUE âœ…' : 'FALSE âŒ'}`, value ? 'success' : 'warning');
            });

            debugLog(`KOZMIC VIBE: ${checks.kozmicVibe ? 'SHREDDING THE COSMOS! ðŸŒŒ' : 'TUNE UP, SHREDDER! âš¡ï¸'}`, checks.kozmicVibe ? 'success' : 'warning');
            debugLog('Boolean check complete! System analysis finished.', 'info');

            const console = safeElement('heuristicConsole');
            console.style.display = 'block';
            console.scrollTop = console.scrollHeight;

            return checks;
        }

        function activateCrisisMode() {
            debugLog('ðŸš¨ CRISIS MODE ACTIVATED', 'error');
            debugLog('Attempting automatic recovery...', 'warning');
            
            if (!audioStream) {
                debugLog('Reconnecting audio...', 'info');
                connectAudio();
            }
            
            if (!renderer) {
                debugLog('Reinitializing WebGL...', 'info');
                initWebGL();
            }
            
            isAmplified = false;
            currentEffect = 'particles';
            particleIntensity = 50;
            
            debugLog('System recovery attempted ðŸ”§', 'success');
        }

        function toggleDebugMode() {
            const console = safeElement('heuristicConsole');
            const isVisible = console.style.display !== 'none';
            console.style.display = isVisible ? 'none' : 'block';
            debugLog(isVisible ? 'Debug mode hidden' : 'Debug mode visible', 'info');
        }

        // SESSION MANAGEMENT WITH FIXED LOAD FUNCTION
        function saveSession() {
            const sessionData = {
                ...heuristicData,
                timestamp: Date.now(),
                effect: currentEffect,
                intensity: particleIntensity,
                amplified: isAmplified
            };

            const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kozmic-session-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            debugLog('Session saved successfully! ðŸ’¾', 'success');
        }

        // FIXED LOAD FUNCTION
        function loadSession() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const sessionData = JSON.parse(e.target.result);
                                currentEffect = sessionData.effect || 'particles';
                                particleIntensity = sessionData.intensity || 50;
                                isAmplified = sessionData.amplified || false;
                                
                                setEffect(currentEffect);
                                safeElement('effectPower').textContent = particleIntensity + '%';
                                safeElement('intensityBtn').textContent = `${particleIntensity}%`;
                                safeElement('amplifyBtn').textContent = isAmplified ? 'AMPLIFIED' : 'AMPLIFY';
                                
                                if (isAmplified) {
                                    safeElement('amplifyBtn').classList.add('active');
                                } else {
                                    safeElement('amplifyBtn').classList.remove('active');
                                }
                                
                                if (scene) {
                                    createParticleSystem();
                                }
                                
                                debugLog('Session loaded successfully! ðŸŒŒ', 'success');
                            } catch (error) {
                                debugLog(`Load failed: ${error.message}`, 'error');
                                alert('Invalid session file!');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            } catch (error) {
                debugLog(`Load failed: ${error.message}`, 'error');
            }
        }

        function exportRecording() {
            if (recordedChunks.length === 0) {
                debugLog('No recordings to export!', 'warning');
                alert('No recordings to export!');
                return;
            }
            
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kozmic-export-${currentEffect}-${Date.now()}.webm`;
            a.click();
            URL.revokeObjectURL(url);
            
            debugLog('Recording exported! ðŸ“¤', 'success');
        }

        function resetSession() {
            sessionStart = Date.now();
            batteryLevel = 100;
            powerSaving = false;
            particleIntensity = 50;
            currentEffect = 'particles';
            isAmplified = false;
            tunerActive = false;
            recordedChunks = [];
            
            safeElement('sessionTime').textContent = '0:00';
            safeElement('modeStatus').textContent = 'PORTABLE';
            
            document.querySelectorAll('.kozmic-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            setEffect('particles');
            
            debugLog('Session reset complete! ðŸ”„', 'success');
        }

        // SESSION TIMER
        function updateSessionTime() {
            const elapsed = Math.floor((Date.now() - sessionStart) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            safeElement('sessionTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // BATTERY SIMULATION
        function updateBattery() {
            if (audioStream || renderer) {
                batteryLevel = Math.max(0, batteryLevel - (powerSaving ? 0.1 : 0.2));
            }

            safeElement('batteryText').textContent = `ðŸ”‹ ${Math.round(batteryLevel)}%`;
            safeElement('batteryFill').style.width = batteryLevel + '%';
            safeElement('batteryStatus').textContent = Math.round(batteryLevel) + '%';

            if (batteryLevel < 30 && !powerSaving) {
                enablePowerSaving();
            }

            if (batteryLevel < 15) {
                debugLog('âš ï¸ Low battery! Consider power saving mode', 'warning');
            }
        }

        function enablePowerSaving() {
            powerSaving = true;
            safeElement('modeStatus').textContent = 'POWER SAVE';
            debugLog('Power saving mode enabled ðŸ”‹', 'warning');
            
            if (renderer) {
                renderer.setPixelRatio(1);
                createParticleSystem();
            }
        }

        // COSMIC CREATURE
        function pulseCreature() {
            creatureClicks++;
            const creature = safeElement('cosmicCreature');
            creature.classList.add('creature-pulse');
            
            setTimeout(() => {
                creature.classList.remove('creature-pulse');
            }, 600);

            if (creatureClicks >= 5) {
                triggerHypernova();
                creatureClicks = 0;
            }

            debugLog(`Cosmic creature pulsed! (${creatureClicks}/5)`, 'info');
        }

        function triggerHypernova() {
            debugLog('ðŸŒŸ HYPERNOVA TRIGGERED! ðŸŒŸ', 'success');
            
            document.body.style.filter = 'brightness(3)';
            setTimeout(() => {
                document.body.style.filter = 'brightness(1)';
            }, 200);

            particles.forEach(particle => {
                const direction = particle.position.clone().normalize();
                particle.position.addScaledVector(direction, 5);
                particle.material.color.setRGB(1, 1, 1);
            });

            setTimeout(() => {
                createParticleSystem();
            }, 1000);
        }

        // SINWE MIXER INTEGRATION
        function detectMixerEffect() {
            if (!analyser || !dataArray) return;
            
            analyser.getByteFrequencyData(dataArray);
            const highFreqSum = dataArray.slice(80).reduce((a, b) => a + b, 0);
            const midFreqSum = dataArray.slice(40, 80).reduce((a, b) => a + b, 0);
            const lowFreqSum = dataArray.slice(0, 40).reduce((a, b) => a + b, 0);
            
            if (highFreqSum > 12000) { 
                setEffect('burst');
                debugLog('SINWE High-Freq Effect detected! Triggering BURST ðŸŒ‹', 'info');
            } else if (midFreqSum > 8000) {
                setEffect('spiral');
                debugLog('SINWE Mid-Freq Effect detected! Triggering SPIRAL ðŸŒªï¸', 'info');
            } else if (lowFreqSum > 6000) {
                setEffect('cosmic');
                debugLog('SINWE Low-Freq Effect detected! Triggering COSMIC ðŸ•³ï¸', 'info');
            }
        }

        function detectBeat() {
            if (!analyser || !dataArray) return;
            
            analyser.getByteFrequencyData(dataArray);
            const energy = dataArray.reduce((a, b) => a + b, 0);
            
            if (energy > beatDetector.lastEnergy * 1.2 && energy > 6000) {
                particles.forEach(particle => {
                    const scale = particle.scale || { setScalar: () => {} };
                    scale.setScalar(1.5);
                    setTimeout(() => scale.setScalar(1), 100);
                });
                debugLog('SINWE Beat detected! Particles pulsing ðŸ¥', 'info');
                
                const creature = safeElement('cosmicCreature');
                creature.classList.add('creature-pulse');
                setTimeout(() => creature.classList.remove('creature-pulse'), 300);
            }
            
            beatDetector.lastEnergy = energy;
            requestAnimationFrame(detectBeat);
        }

        const beatDetector = { lastEnergy: 0 };

        // EVENT LISTENERS
        document.getElementById('connectBtn').onclick = connectAudio;
        document.getElementById('recordBtn').onclick = toggleRecord;
        document.getElementById('tunerBtn').onclick = toggleTuner;
        document.getElementById('amplifyBtn').onclick = toggleAmplify;
        document.getElementById('effectToggle').onclick = toggleEffects;
        document.getElementById('intensityBtn').onclick = adjustIntensity;
        document.getElementById('heuristicBtn').onclick = performHeuristicAnalysis;
        document.getElementById('booleanBtn').onclick = performBooleanCheck;
        document.getElementById('crisisBtn').onclick = activateCrisisMode;
        document.getElementById('debugBtn').onclick = toggleDebugMode;
        document.getElementById('saveBtn').onclick = saveSession;
        document.getElementById('loadBtn').onclick = loadSession;
        document.getElementById('exportBtn').onclick = exportRecording;
        document.getElementById('resetBtn').onclick = resetSession;

        // Effect selector buttons
        document.querySelectorAll('.effect-btn').forEach(btn => {
            btn.onclick = () => setEffect(btn.dataset.effect);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey) {
                switch (e.key) {
                    case 'D': performHeuristicAnalysis(); break;
                    case 'S': saveSession(); break;
                    case 'C': activateCrisisMode(); break;
                    case 'B': performBooleanCheck(); break;
                }
            } else {
                switch (e.key) {
                    case ' ': e.preventDefault(); audioStream ? toggleAmplify() : connectAudio(); break;
                    case 'r': case 'R': toggleRecord(); break;
                    case 't': case 'T': toggleTuner(); break;
                    case 'e': case 'E': toggleEffects(); break;
                    case '1': case '2': case '3': case '4': case '5': case '6':
                        const effects = ['particles', 'nebula', 'waveform', 'cosmic', 'spiral', 'burst'];
                        setEffect(effects[parseInt(e.key) - 1]);
                        break;
                }
            }
        });

        // MOBILE RESPONSIVE
        function handleResize() {
            if (renderer && camera) {
                const container = renderer.domElement.parentElement;
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        // INITIALIZATION
        window.addEventListener('load', () => {
            debugLog('ðŸŒŒ Kozmic Pro Studio initializing...', 'info');
            
            if (initWebGL()) {
                debugLog('WebGL ready! ðŸŽ¨', 'success');
            } else {
                debugLog('WebGL failed, running in audio-only mode ðŸŽµ', 'warning');
            }
            
            setInterval(updateSessionTime, 1000);
            setInterval(updateBattery, 5000);
            
            window.addEventListener('resize', handleResize);
            
            debugLog('ðŸŽ¸ KOZMIC PRO STUDIO READY TO ROCK! ðŸŒŒ', 'success');
            debugLog('Press SPACE to connect audio, or click CONNECT', 'info');
        });

        // MOBILE TOUCH SUPPORT
        let touchStartX, touchStartY;
        
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                if (deltaX > 0) {
                    cycleEffect();
                } else {
                    const effects = ['particles', 'nebula', 'waveform', 'cosmic', 'spiral', 'burst'];
                    const currentIndex = effects.indexOf(currentEffect);
                    const prevIndex = (currentIndex - 1 + effects.length) % effects.length;
                    setEffect(effects[prevIndex]);
                }
            }
        });
    </script>
</body>
</html>
